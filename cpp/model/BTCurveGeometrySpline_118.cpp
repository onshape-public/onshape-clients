/**
 * Onshape REST API
 * The Onshape REST API consumed by all clients.
 *
 * The version of the OpenAPI document: 1.113
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "BTCurveGeometrySpline_118.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




BTCurveGeometrySpline_118::BTCurveGeometrySpline_118()
{
    m_Degree = 0;
    m_DegreeIsSet = false;
    m_IsPeriodic = false;
    m_IsPeriodicIsSet = false;
    m_IsRational = false;
    m_IsRationalIsSet = false;
    m_ControlPointCount = 0;
    m_ControlPointCountIsSet = false;
    m_ControlPointsIsSet = false;
    m_KnotsIsSet = false;
}

BTCurveGeometrySpline_118::~BTCurveGeometrySpline_118()
{
}

void BTCurveGeometrySpline_118::validate()
{
    // TODO: implement validation
}

web::json::value BTCurveGeometrySpline_118::toJson() const
{
    web::json::value val = this->BTCurveGeometry_114::toJson();
    
    if(m_DegreeIsSet)
    {
        val[utility::conversions::to_string_t("degree")] = ModelBase::toJson(m_Degree);
    }
    if(m_IsPeriodicIsSet)
    {
        val[utility::conversions::to_string_t("isPeriodic")] = ModelBase::toJson(m_IsPeriodic);
    }
    if(m_IsRationalIsSet)
    {
        val[utility::conversions::to_string_t("isRational")] = ModelBase::toJson(m_IsRational);
    }
    if(m_ControlPointCountIsSet)
    {
        val[utility::conversions::to_string_t("controlPointCount")] = ModelBase::toJson(m_ControlPointCount);
    }
    if(m_ControlPointsIsSet)
    {
        val[utility::conversions::to_string_t("controlPoints")] = ModelBase::toJson(m_ControlPoints);
    }
    if(m_KnotsIsSet)
    {
        val[utility::conversions::to_string_t("knots")] = ModelBase::toJson(m_Knots);
    }

    return val;
}

bool BTCurveGeometrySpline_118::fromJson(const web::json::value& val)
{
    bool ok = true;
    ok &= this->BTCurveGeometry_114::fromJson(val);
    
    if(val.has_field(utility::conversions::to_string_t("degree")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("degree"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_degree;
            ok &= ModelBase::fromJson(fieldValue, refVal_degree);
            setDegree(refVal_degree);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("isPeriodic")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("isPeriodic"));
        if(!fieldValue.is_null())
        {
            bool refVal_isPeriodic;
            ok &= ModelBase::fromJson(fieldValue, refVal_isPeriodic);
            setIsPeriodic(refVal_isPeriodic);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("isRational")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("isRational"));
        if(!fieldValue.is_null())
        {
            bool refVal_isRational;
            ok &= ModelBase::fromJson(fieldValue, refVal_isRational);
            setIsRational(refVal_isRational);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("controlPointCount")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("controlPointCount"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_controlPointCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_controlPointCount);
            setControlPointCount(refVal_controlPointCount);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("controlPoints")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("controlPoints"));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_controlPoints;
            ok &= ModelBase::fromJson(fieldValue, refVal_controlPoints);
            setControlPoints(refVal_controlPoints);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("knots")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("knots"));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_knots;
            ok &= ModelBase::fromJson(fieldValue, refVal_knots);
            setKnots(refVal_knots);
        }
    }
    return ok;
}

void BTCurveGeometrySpline_118::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_BtTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("btType"), m_BtType));
    }
    if(m_DegreeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("degree"), m_Degree));
    }
    if(m_IsPeriodicIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("isPeriodic"), m_IsPeriodic));
    }
    if(m_IsRationalIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("isRational"), m_IsRational));
    }
    if(m_ControlPointCountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("controlPointCount"), m_ControlPointCount));
    }
    if(m_ControlPointsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("controlPoints"), m_ControlPoints));
    }
    if(m_KnotsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("knots"), m_Knots));
    }
}

bool BTCurveGeometrySpline_118::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("btType")))
    {
        utility::string_t refVal_btType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("btType")), refVal_btType );
        setBtType(refVal_btType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("degree")))
    {
        int32_t refVal_degree;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("degree")), refVal_degree );
        setDegree(refVal_degree);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("isPeriodic")))
    {
        bool refVal_isPeriodic;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("isPeriodic")), refVal_isPeriodic );
        setIsPeriodic(refVal_isPeriodic);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("isRational")))
    {
        bool refVal_isRational;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("isRational")), refVal_isRational );
        setIsRational(refVal_isRational);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("controlPointCount")))
    {
        int32_t refVal_controlPointCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("controlPointCount")), refVal_controlPointCount );
        setControlPointCount(refVal_controlPointCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("controlPoints")))
    {
        std::vector<double> refVal_controlPoints;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("controlPoints")), refVal_controlPoints );
        setControlPoints(refVal_controlPoints);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("knots")))
    {
        std::vector<double> refVal_knots;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("knots")), refVal_knots );
        setKnots(refVal_knots);
    }
    return ok;
}

int32_t BTCurveGeometrySpline_118::getDegree() const
{
    return m_Degree;
}

void BTCurveGeometrySpline_118::setDegree(int32_t value)
{
    m_Degree = value;
    m_DegreeIsSet = true;
}

bool BTCurveGeometrySpline_118::degreeIsSet() const
{
    return m_DegreeIsSet;
}

void BTCurveGeometrySpline_118::unsetDegree()
{
    m_DegreeIsSet = false;
}
bool BTCurveGeometrySpline_118::isIsPeriodic() const
{
    return m_IsPeriodic;
}

void BTCurveGeometrySpline_118::setIsPeriodic(bool value)
{
    m_IsPeriodic = value;
    m_IsPeriodicIsSet = true;
}

bool BTCurveGeometrySpline_118::isPeriodicIsSet() const
{
    return m_IsPeriodicIsSet;
}

void BTCurveGeometrySpline_118::unsetIsPeriodic()
{
    m_IsPeriodicIsSet = false;
}
bool BTCurveGeometrySpline_118::isIsRational() const
{
    return m_IsRational;
}

void BTCurveGeometrySpline_118::setIsRational(bool value)
{
    m_IsRational = value;
    m_IsRationalIsSet = true;
}

bool BTCurveGeometrySpline_118::isRationalIsSet() const
{
    return m_IsRationalIsSet;
}

void BTCurveGeometrySpline_118::unsetIsRational()
{
    m_IsRationalIsSet = false;
}
int32_t BTCurveGeometrySpline_118::getControlPointCount() const
{
    return m_ControlPointCount;
}

void BTCurveGeometrySpline_118::setControlPointCount(int32_t value)
{
    m_ControlPointCount = value;
    m_ControlPointCountIsSet = true;
}

bool BTCurveGeometrySpline_118::controlPointCountIsSet() const
{
    return m_ControlPointCountIsSet;
}

void BTCurveGeometrySpline_118::unsetControlPointCount()
{
    m_ControlPointCountIsSet = false;
}
std::vector<double>& BTCurveGeometrySpline_118::getControlPoints()
{
    return m_ControlPoints;
}

void BTCurveGeometrySpline_118::setControlPoints(std::vector<double> value)
{
    m_ControlPoints = value;
    m_ControlPointsIsSet = true;
}

bool BTCurveGeometrySpline_118::controlPointsIsSet() const
{
    return m_ControlPointsIsSet;
}

void BTCurveGeometrySpline_118::unsetControlPoints()
{
    m_ControlPointsIsSet = false;
}
std::vector<double>& BTCurveGeometrySpline_118::getKnots()
{
    return m_Knots;
}

void BTCurveGeometrySpline_118::setKnots(std::vector<double> value)
{
    m_Knots = value;
    m_KnotsIsSet = true;
}

bool BTCurveGeometrySpline_118::knotsIsSet() const
{
    return m_KnotsIsSet;
}

void BTCurveGeometrySpline_118::unsetKnots()
{
    m_KnotsIsSet = false;
}
}
}
}
}



/**
 * Onshape REST API
 * The Onshape REST API consumed by all clients.
 *
 * The version of the OpenAPI document: 1.113
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "BTSplineDescription_2118.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




BTSplineDescription_2118::BTSplineDescription_2118()
{
    m_Degree = 0;
    m_DegreeIsSet = false;
    m_IsPeriodic = false;
    m_IsPeriodicIsSet = false;
    m_IsRational = false;
    m_IsRationalIsSet = false;
    m_ControlPointsIsSet = false;
    m_KnotsIsSet = false;
}

BTSplineDescription_2118::~BTSplineDescription_2118()
{
}

void BTSplineDescription_2118::validate()
{
    // TODO: implement validation
}

web::json::value BTSplineDescription_2118::toJson() const
{
    web::json::value val = this->BTCurveDescription_1583::toJson();
    
    if(m_DegreeIsSet)
    {
        val[utility::conversions::to_string_t("degree")] = ModelBase::toJson(m_Degree);
    }
    if(m_IsPeriodicIsSet)
    {
        val[utility::conversions::to_string_t("isPeriodic")] = ModelBase::toJson(m_IsPeriodic);
    }
    if(m_IsRationalIsSet)
    {
        val[utility::conversions::to_string_t("isRational")] = ModelBase::toJson(m_IsRational);
    }
    if(m_ControlPointsIsSet)
    {
        val[utility::conversions::to_string_t("controlPoints")] = ModelBase::toJson(m_ControlPoints);
    }
    if(m_KnotsIsSet)
    {
        val[utility::conversions::to_string_t("knots")] = ModelBase::toJson(m_Knots);
    }

    return val;
}

bool BTSplineDescription_2118::fromJson(const web::json::value& val)
{
    bool ok = true;
    ok &= this->BTCurveDescription_1583::fromJson(val);
    
    if(val.has_field(utility::conversions::to_string_t("degree")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("degree"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_degree;
            ok &= ModelBase::fromJson(fieldValue, refVal_degree);
            setDegree(refVal_degree);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("isPeriodic")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("isPeriodic"));
        if(!fieldValue.is_null())
        {
            bool refVal_isPeriodic;
            ok &= ModelBase::fromJson(fieldValue, refVal_isPeriodic);
            setIsPeriodic(refVal_isPeriodic);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("isRational")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("isRational"));
        if(!fieldValue.is_null())
        {
            bool refVal_isRational;
            ok &= ModelBase::fromJson(fieldValue, refVal_isRational);
            setIsRational(refVal_isRational);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("controlPoints")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("controlPoints"));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_controlPoints;
            ok &= ModelBase::fromJson(fieldValue, refVal_controlPoints);
            setControlPoints(refVal_controlPoints);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("knots")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("knots"));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_knots;
            ok &= ModelBase::fromJson(fieldValue, refVal_knots);
            setKnots(refVal_knots);
        }
    }
    return ok;
}

void BTSplineDescription_2118::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_BtTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("btType"), m_BtType));
    }
    if(m_TypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("type"), m_Type));
    }
    if(m_DegreeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("degree"), m_Degree));
    }
    if(m_IsPeriodicIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("isPeriodic"), m_IsPeriodic));
    }
    if(m_IsRationalIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("isRational"), m_IsRational));
    }
    if(m_ControlPointsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("controlPoints"), m_ControlPoints));
    }
    if(m_KnotsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("knots"), m_Knots));
    }
}

bool BTSplineDescription_2118::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("btType")))
    {
        utility::string_t refVal_btType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("btType")), refVal_btType );
        setBtType(refVal_btType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("type")))
    {
        utility::string_t refVal_type;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("type")), refVal_type );
        setType(refVal_type);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("degree")))
    {
        int32_t refVal_degree;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("degree")), refVal_degree );
        setDegree(refVal_degree);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("isPeriodic")))
    {
        bool refVal_isPeriodic;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("isPeriodic")), refVal_isPeriodic );
        setIsPeriodic(refVal_isPeriodic);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("isRational")))
    {
        bool refVal_isRational;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("isRational")), refVal_isRational );
        setIsRational(refVal_isRational);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("controlPoints")))
    {
        std::vector<double> refVal_controlPoints;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("controlPoints")), refVal_controlPoints );
        setControlPoints(refVal_controlPoints);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("knots")))
    {
        std::vector<double> refVal_knots;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("knots")), refVal_knots );
        setKnots(refVal_knots);
    }
    return ok;
}

int32_t BTSplineDescription_2118::getDegree() const
{
    return m_Degree;
}

void BTSplineDescription_2118::setDegree(int32_t value)
{
    m_Degree = value;
    m_DegreeIsSet = true;
}

bool BTSplineDescription_2118::degreeIsSet() const
{
    return m_DegreeIsSet;
}

void BTSplineDescription_2118::unsetDegree()
{
    m_DegreeIsSet = false;
}
bool BTSplineDescription_2118::isIsPeriodic() const
{
    return m_IsPeriodic;
}

void BTSplineDescription_2118::setIsPeriodic(bool value)
{
    m_IsPeriodic = value;
    m_IsPeriodicIsSet = true;
}

bool BTSplineDescription_2118::isPeriodicIsSet() const
{
    return m_IsPeriodicIsSet;
}

void BTSplineDescription_2118::unsetIsPeriodic()
{
    m_IsPeriodicIsSet = false;
}
bool BTSplineDescription_2118::isIsRational() const
{
    return m_IsRational;
}

void BTSplineDescription_2118::setIsRational(bool value)
{
    m_IsRational = value;
    m_IsRationalIsSet = true;
}

bool BTSplineDescription_2118::isRationalIsSet() const
{
    return m_IsRationalIsSet;
}

void BTSplineDescription_2118::unsetIsRational()
{
    m_IsRationalIsSet = false;
}
std::vector<double>& BTSplineDescription_2118::getControlPoints()
{
    return m_ControlPoints;
}

void BTSplineDescription_2118::setControlPoints(std::vector<double> value)
{
    m_ControlPoints = value;
    m_ControlPointsIsSet = true;
}

bool BTSplineDescription_2118::controlPointsIsSet() const
{
    return m_ControlPointsIsSet;
}

void BTSplineDescription_2118::unsetControlPoints()
{
    m_ControlPointsIsSet = false;
}
std::vector<double>& BTSplineDescription_2118::getKnots()
{
    return m_Knots;
}

void BTSplineDescription_2118::setKnots(std::vector<double> value)
{
    m_Knots = value;
    m_KnotsIsSet = true;
}

bool BTSplineDescription_2118::knotsIsSet() const
{
    return m_KnotsIsSet;
}

void BTSplineDescription_2118::unsetKnots()
{
    m_KnotsIsSet = false;
}
}
}
}
}



/**
 * Onshape REST API
 * The Onshape REST API consumed by all clients.
 *
 * The version of the OpenAPI document: 1.113
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "BTCurveGeometryInterpolatedSpline_116_allOf.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




BTCurveGeometryInterpolatedSpline_116_allOf::BTCurveGeometryInterpolatedSpline_116_allOf()
{
    m_IsPeriodic = false;
    m_IsPeriodicIsSet = false;
    m_InterpolationPointsIsSet = false;
    m_StartDerivativeX = 0.0;
    m_StartDerivativeXIsSet = false;
    m_StartDerivativeY = 0.0;
    m_StartDerivativeYIsSet = false;
    m_EndDerivativeX = 0.0;
    m_EndDerivativeXIsSet = false;
    m_EndDerivativeY = 0.0;
    m_EndDerivativeYIsSet = false;
    m_StartHandleX = 0.0;
    m_StartHandleXIsSet = false;
    m_StartHandleY = 0.0;
    m_StartHandleYIsSet = false;
    m_EndHandleX = 0.0;
    m_EndHandleXIsSet = false;
    m_EndHandleY = 0.0;
    m_EndHandleYIsSet = false;
    m_BtType = utility::conversions::to_string_t("");
    m_BtTypeIsSet = false;
}

BTCurveGeometryInterpolatedSpline_116_allOf::~BTCurveGeometryInterpolatedSpline_116_allOf()
{
}

void BTCurveGeometryInterpolatedSpline_116_allOf::validate()
{
    // TODO: implement validation
}

web::json::value BTCurveGeometryInterpolatedSpline_116_allOf::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IsPeriodicIsSet)
    {
        val[utility::conversions::to_string_t("isPeriodic")] = ModelBase::toJson(m_IsPeriodic);
    }
    if(m_InterpolationPointsIsSet)
    {
        val[utility::conversions::to_string_t("interpolationPoints")] = ModelBase::toJson(m_InterpolationPoints);
    }
    if(m_StartDerivativeXIsSet)
    {
        val[utility::conversions::to_string_t("startDerivativeX")] = ModelBase::toJson(m_StartDerivativeX);
    }
    if(m_StartDerivativeYIsSet)
    {
        val[utility::conversions::to_string_t("startDerivativeY")] = ModelBase::toJson(m_StartDerivativeY);
    }
    if(m_EndDerivativeXIsSet)
    {
        val[utility::conversions::to_string_t("endDerivativeX")] = ModelBase::toJson(m_EndDerivativeX);
    }
    if(m_EndDerivativeYIsSet)
    {
        val[utility::conversions::to_string_t("endDerivativeY")] = ModelBase::toJson(m_EndDerivativeY);
    }
    if(m_StartHandleXIsSet)
    {
        val[utility::conversions::to_string_t("startHandleX")] = ModelBase::toJson(m_StartHandleX);
    }
    if(m_StartHandleYIsSet)
    {
        val[utility::conversions::to_string_t("startHandleY")] = ModelBase::toJson(m_StartHandleY);
    }
    if(m_EndHandleXIsSet)
    {
        val[utility::conversions::to_string_t("endHandleX")] = ModelBase::toJson(m_EndHandleX);
    }
    if(m_EndHandleYIsSet)
    {
        val[utility::conversions::to_string_t("endHandleY")] = ModelBase::toJson(m_EndHandleY);
    }
    if(m_BtTypeIsSet)
    {
        val[utility::conversions::to_string_t("btType")] = ModelBase::toJson(m_BtType);
    }

    return val;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("isPeriodic")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("isPeriodic"));
        if(!fieldValue.is_null())
        {
            bool refVal_isPeriodic;
            ok &= ModelBase::fromJson(fieldValue, refVal_isPeriodic);
            setIsPeriodic(refVal_isPeriodic);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("interpolationPoints")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("interpolationPoints"));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_interpolationPoints;
            ok &= ModelBase::fromJson(fieldValue, refVal_interpolationPoints);
            setInterpolationPoints(refVal_interpolationPoints);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("startDerivativeX")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("startDerivativeX"));
        if(!fieldValue.is_null())
        {
            double refVal_startDerivativeX;
            ok &= ModelBase::fromJson(fieldValue, refVal_startDerivativeX);
            setStartDerivativeX(refVal_startDerivativeX);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("startDerivativeY")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("startDerivativeY"));
        if(!fieldValue.is_null())
        {
            double refVal_startDerivativeY;
            ok &= ModelBase::fromJson(fieldValue, refVal_startDerivativeY);
            setStartDerivativeY(refVal_startDerivativeY);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("endDerivativeX")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("endDerivativeX"));
        if(!fieldValue.is_null())
        {
            double refVal_endDerivativeX;
            ok &= ModelBase::fromJson(fieldValue, refVal_endDerivativeX);
            setEndDerivativeX(refVal_endDerivativeX);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("endDerivativeY")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("endDerivativeY"));
        if(!fieldValue.is_null())
        {
            double refVal_endDerivativeY;
            ok &= ModelBase::fromJson(fieldValue, refVal_endDerivativeY);
            setEndDerivativeY(refVal_endDerivativeY);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("startHandleX")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("startHandleX"));
        if(!fieldValue.is_null())
        {
            double refVal_startHandleX;
            ok &= ModelBase::fromJson(fieldValue, refVal_startHandleX);
            setStartHandleX(refVal_startHandleX);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("startHandleY")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("startHandleY"));
        if(!fieldValue.is_null())
        {
            double refVal_startHandleY;
            ok &= ModelBase::fromJson(fieldValue, refVal_startHandleY);
            setStartHandleY(refVal_startHandleY);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("endHandleX")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("endHandleX"));
        if(!fieldValue.is_null())
        {
            double refVal_endHandleX;
            ok &= ModelBase::fromJson(fieldValue, refVal_endHandleX);
            setEndHandleX(refVal_endHandleX);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("endHandleY")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("endHandleY"));
        if(!fieldValue.is_null())
        {
            double refVal_endHandleY;
            ok &= ModelBase::fromJson(fieldValue, refVal_endHandleY);
            setEndHandleY(refVal_endHandleY);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("btType")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("btType"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_btType;
            ok &= ModelBase::fromJson(fieldValue, refVal_btType);
            setBtType(refVal_btType);
        }
    }
    return ok;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_IsPeriodicIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("isPeriodic"), m_IsPeriodic));
    }
    if(m_InterpolationPointsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("interpolationPoints"), m_InterpolationPoints));
    }
    if(m_StartDerivativeXIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("startDerivativeX"), m_StartDerivativeX));
    }
    if(m_StartDerivativeYIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("startDerivativeY"), m_StartDerivativeY));
    }
    if(m_EndDerivativeXIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("endDerivativeX"), m_EndDerivativeX));
    }
    if(m_EndDerivativeYIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("endDerivativeY"), m_EndDerivativeY));
    }
    if(m_StartHandleXIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("startHandleX"), m_StartHandleX));
    }
    if(m_StartHandleYIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("startHandleY"), m_StartHandleY));
    }
    if(m_EndHandleXIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("endHandleX"), m_EndHandleX));
    }
    if(m_EndHandleYIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("endHandleY"), m_EndHandleY));
    }
    if(m_BtTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("btType"), m_BtType));
    }
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("isPeriodic")))
    {
        bool refVal_isPeriodic;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("isPeriodic")), refVal_isPeriodic );
        setIsPeriodic(refVal_isPeriodic);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("interpolationPoints")))
    {
        std::vector<double> refVal_interpolationPoints;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("interpolationPoints")), refVal_interpolationPoints );
        setInterpolationPoints(refVal_interpolationPoints);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("startDerivativeX")))
    {
        double refVal_startDerivativeX;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("startDerivativeX")), refVal_startDerivativeX );
        setStartDerivativeX(refVal_startDerivativeX);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("startDerivativeY")))
    {
        double refVal_startDerivativeY;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("startDerivativeY")), refVal_startDerivativeY );
        setStartDerivativeY(refVal_startDerivativeY);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("endDerivativeX")))
    {
        double refVal_endDerivativeX;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("endDerivativeX")), refVal_endDerivativeX );
        setEndDerivativeX(refVal_endDerivativeX);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("endDerivativeY")))
    {
        double refVal_endDerivativeY;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("endDerivativeY")), refVal_endDerivativeY );
        setEndDerivativeY(refVal_endDerivativeY);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("startHandleX")))
    {
        double refVal_startHandleX;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("startHandleX")), refVal_startHandleX );
        setStartHandleX(refVal_startHandleX);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("startHandleY")))
    {
        double refVal_startHandleY;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("startHandleY")), refVal_startHandleY );
        setStartHandleY(refVal_startHandleY);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("endHandleX")))
    {
        double refVal_endHandleX;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("endHandleX")), refVal_endHandleX );
        setEndHandleX(refVal_endHandleX);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("endHandleY")))
    {
        double refVal_endHandleY;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("endHandleY")), refVal_endHandleY );
        setEndHandleY(refVal_endHandleY);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("btType")))
    {
        utility::string_t refVal_btType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("btType")), refVal_btType );
        setBtType(refVal_btType);
    }
    return ok;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::isIsPeriodic() const
{
    return m_IsPeriodic;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setIsPeriodic(bool value)
{
    m_IsPeriodic = value;
    m_IsPeriodicIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::isPeriodicIsSet() const
{
    return m_IsPeriodicIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetIsPeriodic()
{
    m_IsPeriodicIsSet = false;
}
std::vector<double>& BTCurveGeometryInterpolatedSpline_116_allOf::getInterpolationPoints()
{
    return m_InterpolationPoints;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setInterpolationPoints(std::vector<double> value)
{
    m_InterpolationPoints = value;
    m_InterpolationPointsIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::interpolationPointsIsSet() const
{
    return m_InterpolationPointsIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetInterpolationPoints()
{
    m_InterpolationPointsIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getStartDerivativeX() const
{
    return m_StartDerivativeX;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setStartDerivativeX(double value)
{
    m_StartDerivativeX = value;
    m_StartDerivativeXIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::startDerivativeXIsSet() const
{
    return m_StartDerivativeXIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetStartDerivativeX()
{
    m_StartDerivativeXIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getStartDerivativeY() const
{
    return m_StartDerivativeY;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setStartDerivativeY(double value)
{
    m_StartDerivativeY = value;
    m_StartDerivativeYIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::startDerivativeYIsSet() const
{
    return m_StartDerivativeYIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetStartDerivativeY()
{
    m_StartDerivativeYIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getEndDerivativeX() const
{
    return m_EndDerivativeX;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setEndDerivativeX(double value)
{
    m_EndDerivativeX = value;
    m_EndDerivativeXIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::endDerivativeXIsSet() const
{
    return m_EndDerivativeXIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetEndDerivativeX()
{
    m_EndDerivativeXIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getEndDerivativeY() const
{
    return m_EndDerivativeY;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setEndDerivativeY(double value)
{
    m_EndDerivativeY = value;
    m_EndDerivativeYIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::endDerivativeYIsSet() const
{
    return m_EndDerivativeYIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetEndDerivativeY()
{
    m_EndDerivativeYIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getStartHandleX() const
{
    return m_StartHandleX;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setStartHandleX(double value)
{
    m_StartHandleX = value;
    m_StartHandleXIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::startHandleXIsSet() const
{
    return m_StartHandleXIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetStartHandleX()
{
    m_StartHandleXIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getStartHandleY() const
{
    return m_StartHandleY;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setStartHandleY(double value)
{
    m_StartHandleY = value;
    m_StartHandleYIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::startHandleYIsSet() const
{
    return m_StartHandleYIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetStartHandleY()
{
    m_StartHandleYIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getEndHandleX() const
{
    return m_EndHandleX;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setEndHandleX(double value)
{
    m_EndHandleX = value;
    m_EndHandleXIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::endHandleXIsSet() const
{
    return m_EndHandleXIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetEndHandleX()
{
    m_EndHandleXIsSet = false;
}
double BTCurveGeometryInterpolatedSpline_116_allOf::getEndHandleY() const
{
    return m_EndHandleY;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setEndHandleY(double value)
{
    m_EndHandleY = value;
    m_EndHandleYIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::endHandleYIsSet() const
{
    return m_EndHandleYIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetEndHandleY()
{
    m_EndHandleYIsSet = false;
}
utility::string_t BTCurveGeometryInterpolatedSpline_116_allOf::getBtType() const
{
    return m_BtType;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::setBtType(const utility::string_t& value)
{
    m_BtType = value;
    m_BtTypeIsSet = true;
}

bool BTCurveGeometryInterpolatedSpline_116_allOf::btTypeIsSet() const
{
    return m_BtTypeIsSet;
}

void BTCurveGeometryInterpolatedSpline_116_allOf::unsetBtType()
{
    m_BtTypeIsSet = false;
}
}
}
}
}



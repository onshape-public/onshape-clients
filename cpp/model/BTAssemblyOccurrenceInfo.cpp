/**
 * Onshape REST API
 * The Onshape REST API consumed by all clients.
 *
 * The version of the OpenAPI document: 1.113
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "BTAssemblyOccurrenceInfo.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




BTAssemblyOccurrenceInfo::BTAssemblyOccurrenceInfo()
{
    m_Fixed = false;
    m_FixedIsSet = false;
    m_Hidden = false;
    m_HiddenIsSet = false;
    m_PathIsSet = false;
    m_TransformIsSet = false;
}

BTAssemblyOccurrenceInfo::~BTAssemblyOccurrenceInfo()
{
}

void BTAssemblyOccurrenceInfo::validate()
{
    // TODO: implement validation
}

web::json::value BTAssemblyOccurrenceInfo::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_FixedIsSet)
    {
        val[utility::conversions::to_string_t("fixed")] = ModelBase::toJson(m_Fixed);
    }
    if(m_HiddenIsSet)
    {
        val[utility::conversions::to_string_t("hidden")] = ModelBase::toJson(m_Hidden);
    }
    if(m_PathIsSet)
    {
        val[utility::conversions::to_string_t("path")] = ModelBase::toJson(m_Path);
    }
    if(m_TransformIsSet)
    {
        val[utility::conversions::to_string_t("transform")] = ModelBase::toJson(m_Transform);
    }

    return val;
}

bool BTAssemblyOccurrenceInfo::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("fixed")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("fixed"));
        if(!fieldValue.is_null())
        {
            bool refVal_fixed;
            ok &= ModelBase::fromJson(fieldValue, refVal_fixed);
            setFixed(refVal_fixed);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("hidden")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("hidden"));
        if(!fieldValue.is_null())
        {
            bool refVal_hidden;
            ok &= ModelBase::fromJson(fieldValue, refVal_hidden);
            setHidden(refVal_hidden);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("path")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("path"));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_path;
            ok &= ModelBase::fromJson(fieldValue, refVal_path);
            setPath(refVal_path);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("transform")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("transform"));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_transform;
            ok &= ModelBase::fromJson(fieldValue, refVal_transform);
            setTransform(refVal_transform);
        }
    }
    return ok;
}

void BTAssemblyOccurrenceInfo::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_FixedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("fixed"), m_Fixed));
    }
    if(m_HiddenIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("hidden"), m_Hidden));
    }
    if(m_PathIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("path"), m_Path));
    }
    if(m_TransformIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("transform"), m_Transform));
    }
}

bool BTAssemblyOccurrenceInfo::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("fixed")))
    {
        bool refVal_fixed;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("fixed")), refVal_fixed );
        setFixed(refVal_fixed);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("hidden")))
    {
        bool refVal_hidden;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("hidden")), refVal_hidden );
        setHidden(refVal_hidden);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("path")))
    {
        std::vector<utility::string_t> refVal_path;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("path")), refVal_path );
        setPath(refVal_path);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("transform")))
    {
        std::vector<double> refVal_transform;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("transform")), refVal_transform );
        setTransform(refVal_transform);
    }
    return ok;
}

bool BTAssemblyOccurrenceInfo::isFixed() const
{
    return m_Fixed;
}

void BTAssemblyOccurrenceInfo::setFixed(bool value)
{
    m_Fixed = value;
    m_FixedIsSet = true;
}

bool BTAssemblyOccurrenceInfo::fixedIsSet() const
{
    return m_FixedIsSet;
}

void BTAssemblyOccurrenceInfo::unsetFixed()
{
    m_FixedIsSet = false;
}
bool BTAssemblyOccurrenceInfo::isHidden() const
{
    return m_Hidden;
}

void BTAssemblyOccurrenceInfo::setHidden(bool value)
{
    m_Hidden = value;
    m_HiddenIsSet = true;
}

bool BTAssemblyOccurrenceInfo::hiddenIsSet() const
{
    return m_HiddenIsSet;
}

void BTAssemblyOccurrenceInfo::unsetHidden()
{
    m_HiddenIsSet = false;
}
std::vector<utility::string_t>& BTAssemblyOccurrenceInfo::getPath()
{
    return m_Path;
}

void BTAssemblyOccurrenceInfo::setPath(const std::vector<utility::string_t>& value)
{
    m_Path = value;
    m_PathIsSet = true;
}

bool BTAssemblyOccurrenceInfo::pathIsSet() const
{
    return m_PathIsSet;
}

void BTAssemblyOccurrenceInfo::unsetPath()
{
    m_PathIsSet = false;
}
std::vector<double>& BTAssemblyOccurrenceInfo::getTransform()
{
    return m_Transform;
}

void BTAssemblyOccurrenceInfo::setTransform(std::vector<double> value)
{
    m_Transform = value;
    m_TransformIsSet = true;
}

bool BTAssemblyOccurrenceInfo::transformIsSet() const
{
    return m_TransformIsSet;
}

void BTAssemblyOccurrenceInfo::unsetTransform()
{
    m_TransformIsSet = false;
}
}
}
}
}



/**
 * Onshape REST API
 * The Onshape REST API consumed by all clients.
 *
 * The version of the OpenAPI document: 1.113
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "BlobElementsApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

BlobElementsApi::BlobElementsApi( std::shared_ptr<const ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

BlobElementsApi::~BlobElementsApi()
{
}

pplx::task<std::shared_ptr<BTTranslationRequestInfo>> BlobElementsApi::createBlobTranslation(utility::string_t did, utility::string_t wv, utility::string_t wvid, utility::string_t eid, std::shared_ptr<BTTranslateFormatParams> bTTranslateFormatParams) const
{

    // verify the required parameter 'bTTranslateFormatParams' is set
    if (bTTranslateFormatParams == nullptr)
    {
        throw ApiException(400, utility::conversions::to_string_t("Missing required parameter 'bTTranslateFormatParams' when calling BlobElementsApi->createBlobTranslation"));
    }


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/blobelements/d/{did}/{wv}/{wvid}/e/{eid}/translations");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("did") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(did));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("wv") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(wv));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("wvid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(wvid));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("eid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(eid));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("BlobElementsApi->createBlobTranslation does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/json;charset=UTF-8; qs=0.09") );


    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
        web::json::value localVarJson;

        localVarJson = ModelBase::toJson(bTTranslateFormatParams);
        

        localVarHttpBody = std::shared_ptr<IHttpBody>( new JsonBody( localVarJson ) );
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
        std::shared_ptr<MultipartFormData> localVarMultipart(new MultipartFormData);

        if(bTTranslateFormatParams.get())
        {
            bTTranslateFormatParams->toMultipart(localVarMultipart, utility::conversions::to_string_t("bTTranslateFormatParams"));
        }
        

        localVarHttpBody = localVarMultipart;
        localVarRequestHttpContentType += utility::conversions::to_string_t("; boundary=") + localVarMultipart->getBoundary();
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("BlobElementsApi->createBlobTranslation does not consume any supported media type"));
    }

    // authentication (OAuth2) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling createBlobTranslation: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling createBlobTranslation: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::shared_ptr<BTTranslationRequestInfo> localVarResult(new BTTranslationRequestInfo());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling createBlobTranslation: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<HttpContent>> BlobElementsApi::downloadFileWorkspace(utility::string_t did, utility::string_t wid, utility::string_t eid, boost::optional<utility::string_t> contentDisposition, boost::optional<utility::string_t> ifNoneMatch, boost::optional<utility::string_t> linkDocumentId) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/blobelements/d/{did}/w/{wid}/e/{eid}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("did") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(did));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("wid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(wid));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("eid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(eid));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/octet-stream") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        //It's going to be binary, so just use the first one.
        localVarResponseHttpContentType = *localVarResponseHttpContentTypes.begin();
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    if (contentDisposition)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentDisposition")] = ApiClient::parameterToString(*contentDisposition);
    }
    if (ifNoneMatch)
    {
        localVarHeaderParams[utility::conversions::to_string_t("If-None-Match")] = ApiClient::parameterToString(*ifNoneMatch);
    }
    if (linkDocumentId)
    {
        localVarQueryParams[utility::conversions::to_string_t("linkDocumentId")] = ApiClient::parameterToString(*linkDocumentId);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("BlobElementsApi->downloadFileWorkspace does not consume any supported media type"));
    }

    // authentication (OAuth2) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling downloadFileWorkspace: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling downloadFileWorkspace: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_vector();
    })
    .then([=](std::vector<unsigned char> localVarResponse)
    {
        std::shared_ptr<HttpContent> localVarResult;
        std::shared_ptr<std::stringstream> stream = std::make_shared<std::stringstream>(std::string(localVarResponse.begin(), localVarResponse.end()));
        localVarResult->setData(stream);
        return localVarResult;
    });
}
pplx::task<std::shared_ptr<BTDocumentElementProcessingInfo>> BlobElementsApi::updateUnits(utility::string_t did, utility::string_t eid, utility::string_t wid, std::shared_ptr<BTUpdateMeshUnitsParams> bTUpdateMeshUnitsParams) const
{

    // verify the required parameter 'bTUpdateMeshUnitsParams' is set
    if (bTUpdateMeshUnitsParams == nullptr)
    {
        throw ApiException(400, utility::conversions::to_string_t("Missing required parameter 'bTUpdateMeshUnitsParams' when calling BlobElementsApi->updateUnits"));
    }


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/blobelements/d/{did}/w/{wid}/e/{eid}/units");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("did") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(did));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("eid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(eid));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("wid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(wid));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("BlobElementsApi->updateUnits does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/json;charset=UTF-8; qs=0.09") );


    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
        web::json::value localVarJson;

        localVarJson = ModelBase::toJson(bTUpdateMeshUnitsParams);
        

        localVarHttpBody = std::shared_ptr<IHttpBody>( new JsonBody( localVarJson ) );
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
        std::shared_ptr<MultipartFormData> localVarMultipart(new MultipartFormData);

        if(bTUpdateMeshUnitsParams.get())
        {
            bTUpdateMeshUnitsParams->toMultipart(localVarMultipart, utility::conversions::to_string_t("bTUpdateMeshUnitsParams"));
        }
        

        localVarHttpBody = localVarMultipart;
        localVarRequestHttpContentType += utility::conversions::to_string_t("; boundary=") + localVarMultipart->getBoundary();
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("BlobElementsApi->updateUnits does not consume any supported media type"));
    }

    // authentication (OAuth2) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling updateUnits: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling updateUnits: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::shared_ptr<BTDocumentElementProcessingInfo> localVarResult(new BTDocumentElementProcessingInfo());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling updateUnits: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<BTDocumentElementProcessingInfo>> BlobElementsApi::uploadFileCreateElement(utility::string_t did, utility::string_t wid, boost::optional<bool> allowFaultyParts, boost::optional<bool> createComposite, boost::optional<bool> createDrawingIfPossible, boost::optional<utility::string_t> encodedFilename, boost::optional<bool> extractAssemblyHierarchy, boost::optional<std::shared_ptr<HttpContent>> file, boost::optional<std::shared_ptr<FormDataBodyPart>> fileBodyWithDetails, boost::optional<int64_t> fileContentLength, boost::optional<std::shared_ptr<FormDataContentDisposition>> fileDetail, boost::optional<bool> flattenAssemblies, boost::optional<utility::string_t> formatName, boost::optional<bool> isyAxisIsUp, boost::optional<bool> joinAdjacentSurfaces, boost::optional<utility::string_t> locationElementId, boost::optional<utility::string_t> locationGroupId, boost::optional<int32_t> locationPosition, boost::optional<bool> notifyUser, boost::optional<utility::string_t> ownerId, boost::optional<utility::string_t> ownerType, boost::optional<utility::string_t> parentId, boost::optional<utility::string_t> projectId, boost::optional<bool> r_public, boost::optional<bool> splitAssembliesIntoMultipleDocuments, boost::optional<bool> storeInDocument, boost::optional<bool> translate, boost::optional<utility::string_t> unit, boost::optional<utility::string_t> uploadId, boost::optional<utility::string_t> versionString) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/blobelements/d/{did}/w/{wid}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("did") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(did));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("wid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(wid));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("BlobElementsApi->uploadFileCreateElement does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("multipart/form-data") );

    if (allowFaultyParts)
    {
        localVarFormParams[ utility::conversions::to_string_t("allowFaultyParts") ] = ApiClient::parameterToString(*allowFaultyParts);
    }
    if (createComposite)
    {
        localVarFormParams[ utility::conversions::to_string_t("createComposite") ] = ApiClient::parameterToString(*createComposite);
    }
    if (createDrawingIfPossible)
    {
        localVarFormParams[ utility::conversions::to_string_t("createDrawingIfPossible") ] = ApiClient::parameterToString(*createDrawingIfPossible);
    }
    if (encodedFilename)
    {
        localVarFormParams[ utility::conversions::to_string_t("encodedFilename") ] = ApiClient::parameterToString(*encodedFilename);
    }
    if (extractAssemblyHierarchy)
    {
        localVarFormParams[ utility::conversions::to_string_t("extractAssemblyHierarchy") ] = ApiClient::parameterToString(*extractAssemblyHierarchy);
    }
    if (file && *file != nullptr)
    {
        localVarFileParams[ utility::conversions::to_string_t("file") ] = *file;
    }
    if (fileBodyWithDetails && *fileBodyWithDetails != nullptr)
    {
        localVarFormParams[ utility::conversions::to_string_t("fileBodyWithDetails") ] = ApiClient::parameterToString(*fileBodyWithDetails);
    }
    if (fileContentLength)
    {
        localVarFormParams[ utility::conversions::to_string_t("fileContentLength") ] = ApiClient::parameterToString(*fileContentLength);
    }
    if (fileDetail && *fileDetail != nullptr)
    {
        localVarFormParams[ utility::conversions::to_string_t("fileDetail") ] = ApiClient::parameterToString(*fileDetail);
    }
    if (flattenAssemblies)
    {
        localVarFormParams[ utility::conversions::to_string_t("flattenAssemblies") ] = ApiClient::parameterToString(*flattenAssemblies);
    }
    if (formatName)
    {
        localVarFormParams[ utility::conversions::to_string_t("formatName") ] = ApiClient::parameterToString(*formatName);
    }
    if (isyAxisIsUp)
    {
        localVarFormParams[ utility::conversions::to_string_t("isyAxisIsUp") ] = ApiClient::parameterToString(*isyAxisIsUp);
    }
    if (joinAdjacentSurfaces)
    {
        localVarFormParams[ utility::conversions::to_string_t("joinAdjacentSurfaces") ] = ApiClient::parameterToString(*joinAdjacentSurfaces);
    }
    if (locationElementId)
    {
        localVarFormParams[ utility::conversions::to_string_t("locationElementId") ] = ApiClient::parameterToString(*locationElementId);
    }
    if (locationGroupId)
    {
        localVarFormParams[ utility::conversions::to_string_t("locationGroupId") ] = ApiClient::parameterToString(*locationGroupId);
    }
    if (locationPosition)
    {
        localVarFormParams[ utility::conversions::to_string_t("locationPosition") ] = ApiClient::parameterToString(*locationPosition);
    }
    if (notifyUser)
    {
        localVarFormParams[ utility::conversions::to_string_t("notifyUser") ] = ApiClient::parameterToString(*notifyUser);
    }
    if (ownerId)
    {
        localVarFormParams[ utility::conversions::to_string_t("ownerId") ] = ApiClient::parameterToString(*ownerId);
    }
    if (ownerType)
    {
        localVarFormParams[ utility::conversions::to_string_t("ownerType") ] = ApiClient::parameterToString(*ownerType);
    }
    if (parentId)
    {
        localVarFormParams[ utility::conversions::to_string_t("parentId") ] = ApiClient::parameterToString(*parentId);
    }
    if (projectId)
    {
        localVarFormParams[ utility::conversions::to_string_t("projectId") ] = ApiClient::parameterToString(*projectId);
    }
    if (r_public)
    {
        localVarFormParams[ utility::conversions::to_string_t("public") ] = ApiClient::parameterToString(*r_public);
    }
    if (splitAssembliesIntoMultipleDocuments)
    {
        localVarFormParams[ utility::conversions::to_string_t("splitAssembliesIntoMultipleDocuments") ] = ApiClient::parameterToString(*splitAssembliesIntoMultipleDocuments);
    }
    if (storeInDocument)
    {
        localVarFormParams[ utility::conversions::to_string_t("storeInDocument") ] = ApiClient::parameterToString(*storeInDocument);
    }
    if (translate)
    {
        localVarFormParams[ utility::conversions::to_string_t("translate") ] = ApiClient::parameterToString(*translate);
    }
    if (unit)
    {
        localVarFormParams[ utility::conversions::to_string_t("unit") ] = ApiClient::parameterToString(*unit);
    }
    if (uploadId)
    {
        localVarFormParams[ utility::conversions::to_string_t("uploadId") ] = ApiClient::parameterToString(*uploadId);
    }
    if (versionString)
    {
        localVarFormParams[ utility::conversions::to_string_t("versionString") ] = ApiClient::parameterToString(*versionString);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("BlobElementsApi->uploadFileCreateElement does not consume any supported media type"));
    }

    // authentication (OAuth2) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling uploadFileCreateElement: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling uploadFileCreateElement: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::shared_ptr<BTDocumentElementProcessingInfo> localVarResult(new BTDocumentElementProcessingInfo());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling uploadFileCreateElement: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<BTDocumentElementProcessingInfo>> BlobElementsApi::uploadFileUpdateElement(utility::string_t did, utility::string_t eid, utility::string_t wid, boost::optional<utility::string_t> parentChangeId) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/blobelements/d/{did}/w/{wid}/e/{eid}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("did") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(did));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("eid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(eid));
boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("wid") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(wid));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("BlobElementsApi->uploadFileUpdateElement does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    if (parentChangeId)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentChangeId")] = ApiClient::parameterToString(*parentChangeId);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("BlobElementsApi->uploadFileUpdateElement does not consume any supported media type"));
    }

    // authentication (OAuth2) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling uploadFileUpdateElement: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling uploadFileUpdateElement: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::shared_ptr<BTDocumentElementProcessingInfo> localVarResult(new BTDocumentElementProcessingInfo());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling uploadFileUpdateElement: unsupported response type"));
        }

        return localVarResult;
    });
}

}
}
}
}

